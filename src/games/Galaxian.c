#include "Galaxian.h"
// line 7486: void galaxian_state::galaxian_base(machine_config &config)
// line 8828: void galaxian_state::init_galaxian()

struct GfxLayout galaxianTileLayout = {
    8, 8,             /* 8*8 characters */
    256,              /* 256 characters */
    2,                /* 2 bits per pixel */
    {0, 256 * 8 * 8}, /* the two bitplanes are separated */
    {0, 1, 2, 3, 4, 5, 6, 7},
    {0 * 8, 1 * 8, 2 * 8, 3 * 8, 4 * 8, 5 * 8, 6 * 8, 7 * 8},
    8 * 8 /* every char takes 8 consecutive bytes */
};

struct GfxLayout galaxianSpriteLayout = {
    16, 16,            /* 16*16 sprites */
    64,                /* 64 sprites */
    2,                 /* 2 bits per pixel */
    {0, 64 * 16 * 16}, /* the two bitplanes are separated */
    {0, 1, 2, 3, 4, 5, 6, 7, 8 * 8 + 0, 8 * 8 + 1, 8 * 8 + 2, 8 * 8 + 3, 8 * 8 + 4, 8 * 8 + 5, 8 * 8 + 6, 8 * 8 + 7},
    {0 * 8, 1 * 8, 2 * 8, 3 * 8, 4 * 8, 5 * 8, 6 * 8, 7 * 8, 16 * 8, 17 * 8, 18 * 8, 19 * 8, 20 * 8, 21 * 8, 22 * 8, 23 * 8},
    32 * 8 /* every sprite takes 32 consecutive bytes */
};

struct GfxLayout galaxianBulletlayout = {
    /* there is no gfx ROM for this one, it is generated by the hardware */
    3,
    1, /* 3*1 line */
    1, /* just one */
    1, /* 1 bit per pixel */
    {0},
    {2, 2, 2}, /* I "know" that this bit of the */
    {0},       /* graphics ROMs is 1 */
    0          /* no use */
};

#define GALAXIAN_SPRITES_NUMBER 8

void galaxian_interrupt_enable_w(int offset, int data)
{
    if (data & 1)
        Z80AskForNMI[Z80CurrentCpu] = true;
    else
        Z80AskForNMI[Z80CurrentCpu] = false;
}

void galaxian_stars_w(int offset, int data) {}

bool galaxianFlipX = false;
void galaxian_flipx_w(int offset, int data) { galaxianFlipX = data & 1; }

bool galaxianFlipY = false;
void galaxian_flipy_w(int offset, int data) { galaxianFlipY = data & 1; }

void GalaxianInit()
{
    GameInitTilesAndSprites(GALAXIAN_SPRITES_NUMBER, 16, 16, 0x400 + 0x20, 8, 8);
}

void GalaxianRefreshScreen()
{
    // all tiles on screen
    element = allGfx[0];
    visibleArea = VISIBLE_AREA_FULL;
    for (int offset = 0x400 - 1; offset >= 0; offset--)
    {
        // int sx = offs % 32;
        // int sy = offs / 32;
        // int sx = (31 - offs / 32);
        // int sy = (offs % 32);
        // Because screen is rotate
        uint16_t atY = offset % 32;
        uint16_t atX = offset / 32;
        if (!galaxianFlipX)
            atX = 31 - atX;
        if (galaxianFlipY)
            atY = 31 - atY;
        uint8_t tileIndex = boardMemory[0x5000 + offset];
        uint8_t paletteIndex = boardMemory[0x5800 + 2 * (offset % 32) + 1] & 0x07;
        // GameDrawElement(screenBitmap, atX * 8, atY * 8, galaxianFlipX, galaxianFlipY, tileIndex, paletteIndex, TRANSPARENCY_NONE, TRANSPARENT_NONE_COLOR);
        GameDrawTileOnBitmap(offset, tileIndex, paletteIndex, atX * 8, atY * 8, galaxianFlipX, galaxianFlipY);
    }

    visibleArea = allGames[currentGame].video.visibleArea;
    // scroll
    for (uint8_t l = 0; l < 32; l++)
    {
        uint8_t scroll = boardMemory[0x5800 + 2 * l] % screenGameWidth;
        GameScrollLine(l, scroll, 8);
    }
    // Draw the bullets
    element = allGfx[2];
    visibleArea = allGames[currentGame].video.visibleArea;
    for (uint8_t offset = 0; offset < 0x20; offset += 4)
    {
        uint8_t paletteIndex = 6; // 1; /* white */
        if (offset == 7 * 4)
            paletteIndex = 7;                                      // 0; /* yellow */
        uint16_t atY = 255 - boardMemory[0x5860 + offset + 3] - 1; // Machine->drv->gfxdecodeinfo[2].gfxlayout->width;
        uint16_t atX = boardMemory[0x5860 + offset + 1];
        if (galaxianFlipY)
            atY = 255 - atY;
        if (atX < screenGameWidth - 4)
        {
            //GameDrawElement(screenGame, atX, atY, galaxianFlipX, galaxianFlipY, 0, paletteIndex, TRANSPARENCY_BLACK, TRANSPARENT_NONE_COLOR);
            GameDrawTile(0x400 + offset, 0, paletteIndex, atX, atY, galaxianFlipX, galaxianFlipY);
        }
    }
    // all sprites
    element = allGfx[1];
    visibleArea = allGames[currentGame].video.visibleArea;
    for (int spriteNumber = 7; spriteNumber >= 0; spriteNumber--)
    {
        const uint8_t *base = &boardMemory[0x5840 + spriteNumber * 4];
        uint8_t atX = base[0];
        uint16_t spriteIndex = base[1] & 0x3f;
        uint8_t flipX = base[1] & 0x40;
        uint8_t flipY = base[1] & 0x80;
        uint8_t paletteIndex = base[2] & 7;
        uint16_t atY = base[3];
        GameDrawSprite(spriteNumber, spriteIndex, paletteIndex, atX, atY, flipX, flipY);
    }
}
