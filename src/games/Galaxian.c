#include "Galaxian.h"
// line 7486: void galaxian_state::galaxian_base(machine_config &config)
// line 8828: void galaxian_state::init_galaxian()

struct GfxLayout galaxianTileLayout = {
    8, 8,             /* 8*8 characters */
    256,              /* 256 characters */
    2,                /* 2 bits per pixel */
    {0, 256 * 8 * 8}, /* the two bitplanes are separated */
    {0, 1, 2, 3, 4, 5, 6, 7},
    {0 * 8, 1 * 8, 2 * 8, 3 * 8, 4 * 8, 5 * 8, 6 * 8, 7 * 8},
    8 * 8 /* every char takes 8 consecutive bytes */
};

struct GfxLayout galaxianSpriteLayout = {
    16, 16,            /* 16*16 sprites */
    64,                /* 64 sprites */
    2,                 /* 2 bits per pixel */
    {0, 64 * 16 * 16}, /* the two bitplanes are separated */
    {0, 1, 2, 3, 4, 5, 6, 7, 8 * 8 + 0, 8 * 8 + 1, 8 * 8 + 2, 8 * 8 + 3, 8 * 8 + 4, 8 * 8 + 5, 8 * 8 + 6, 8 * 8 + 7},
    {0 * 8, 1 * 8, 2 * 8, 3 * 8, 4 * 8, 5 * 8, 6 * 8, 7 * 8, 16 * 8, 17 * 8, 18 * 8, 19 * 8, 20 * 8, 21 * 8, 22 * 8, 23 * 8},
    32 * 8 /* every sprite takes 32 consecutive bytes */
};

struct GfxLayout galaxianBulletlayout = {
    /* there is no gfx ROM for this one, it is generated by the hardware */
    3,
    1, /* 3*1 line */
    1, /* just one */
    1, /* 1 bit per pixel */
    {0},
    {2, 2, 2}, /* I "know" that this bit of the */
    {0},       /* graphics ROMs is 1 */
    0          /* no use */
};

void galaxian_interrupt_enable_w(int offset, int data) { 
    if (data & 1)
        Z80AskForNMI[Z80CurrentCpu] = true;
    else
        Z80AskForNMI[Z80CurrentCpu] = false;
 }

void galaxian_stars_w(int offset, int data) { }


void GalaxianRefreshScreen()
{
    element = allGfx[0];
    visibleArea = VISIBLE_AREA_FULL;
    for (int offs = 0x400 - 1; offs >= 0; offs--)
    {
        //int sx = offs % 32;
        //int sy = offs / 32;
        int sx = (31 - offs / 32);
        int sy = (offs % 32);
        int tileIndex = boardMemory[0x5000 + offs];
        int paletteIndex = boardMemory[0x5800 + 2 * (offs % 32) + 1] & 0x07;
        //paletteIndex=1;
        GameDrawElement(screenData, sx * 8, sy * 8, false, false, tileIndex, paletteIndex, TRANSPARENCY_NONE, TRANSPARENT_NONE_COLOR);

        // drawgfx(tmpbitmap, Machine->gfx[0],
        //         charcode,
        //         galaxian_attributesram[2 * (offs % 32) + 1] & 0x07,
        //         flipscreen[0], flipscreen[1],
        //         8 * sx, 8 * sy,
        //         0, TRANSPARENCY_NONE, 0);
    }

    element = allGfx[1];
    visibleArea = allGames[currentGame].video.visibleArea;
    //for (int offs = 0x20 - 4; offs >= 0; offs -= 4)
    //{
    //    int flipx, flipy, sx, sy, spritecode;
    //    sx = (boardMemory[0x5840 + offs + 3] + 1) & 0xff; /* ??? */
    //    sy = 240 - boardMemory[0x5840 + offs];
    //    spritecode = boardMemory[0x5840 + offs + 1];
    //    GameDrawElement(screenData, sx, 240 - sy, false, false, spritecode, 1, TRANSPARENCY_NONE, TRANSPARENT_NONE_COLOR);
    //    // drawgfx(bitmap,Machine->gfx[1],
    //    //		spritecode,
    //    //		spriteram[offs + 2] & 0x07,
    //    //		flipx,flipy,
    //    //		sx,sy,
    //    //		flipscreen[0] ? &spritevisibleareaflipx : &spritevisiblearea,TRANSPARENCY_PEN,0);
    //}
    for (int spriteNumber = 7; spriteNumber >= 0; spriteNumber--)
    {    
        const uint8_t *base = &boardMemory[0x5840 + spriteNumber * 4];
        if (base[3])
        {
            uint8_t base0 = ((base[0] >> 4) | (base[0] << 4));
            uint8_t sy = 240 - (base0 - (spriteNumber >= 3));
            uint16_t code = base[1] & 0x3f;
            uint8_t flipx = base[1] & 0x40;
            uint8_t flipy = base[1] & 0x80;
            uint8_t color = base[2] & 7;
            color = ((color >> 1) & 0x03) | ((color << 2) & 0x04);
            const int hoffset = 1;
            uint8_t sx = base[3] + hoffset;
            // sx = 240 - sx;
            sy = 240 - sy;
            GameDrawElement(screenData, sy, sx, flipx, flipy, code, color, TRANSPARENCY_BLACK, TRANSPARENT_NONE_COLOR);
        }  
    }  
}
