#include "Galaxian.h"
// line 7486: void galaxian_state::galaxian_base(machine_config &config)
// line 8828: void galaxian_state::init_galaxian()

struct GfxLayout galaxianTileLayout = {
    8, 8,             /* 8*8 characters */
    256,              /* 256 characters */
    2,                /* 2 bits per pixel */
    {0, 256 * 8 * 8}, /* the two bitplanes are separated */
    {0, 1, 2, 3, 4, 5, 6, 7},
    {0 * 8, 1 * 8, 2 * 8, 3 * 8, 4 * 8, 5 * 8, 6 * 8, 7 * 8},
    8 * 8 /* every char takes 8 consecutive bytes */
};

struct GfxLayout galaxianSpriteLayout = {
    16, 16,            /* 16*16 sprites */
    64,                /* 64 sprites */
    2,                 /* 2 bits per pixel */
    {0, 64 * 16 * 16}, /* the two bitplanes are separated */
    {0, 1, 2, 3, 4, 5, 6, 7, 8 * 8 + 0, 8 * 8 + 1, 8 * 8 + 2, 8 * 8 + 3, 8 * 8 + 4, 8 * 8 + 5, 8 * 8 + 6, 8 * 8 + 7},
    {0 * 8, 1 * 8, 2 * 8, 3 * 8, 4 * 8, 5 * 8, 6 * 8, 7 * 8, 16 * 8, 17 * 8, 18 * 8, 19 * 8, 20 * 8, 21 * 8, 22 * 8, 23 * 8},
    32 * 8 /* every sprite takes 32 consecutive bytes */
};

struct GfxLayout galaxianBulletlayout = {
    /* there is no gfx ROM for this one, it is generated by the hardware */
    3,
    1, /* 3*1 line */
    1, /* just one */
    1, /* 1 bit per pixel */
    {0},
    {2, 2, 2}, /* I "know" that this bit of the */
    {0},       /* graphics ROMs is 1 */
    0          /* no use */
};

void galaxian_interrupt_enable_w(int offset, int data)
{
    if (data & 1)
        Z80AskForNMI[Z80CurrentCpu] = true;
    else
        Z80AskForNMI[Z80CurrentCpu] = false;
}

void galaxian_stars_w(int offset, int data) {}

bool galaxianFlipX = false;
void galaxian_flipx_w(int offset, int data) { galaxianFlipX = data & 1; }

bool galaxianFlipY = false;
void galaxian_flipy_w(int offset, int data) { galaxianFlipY = data & 1; }

void GalaxianInit()
{
}

void GalaxianRefreshScreen()
{
    element = allGfx[0];
    visibleArea = VISIBLE_AREA_FULL;
    for (int offs = 0x400 - 1; offs >= 0; offs--)
    {
        // int sx = offs % 32;
        // int sy = offs / 32;
        // int sx = (31 - offs / 32);
        // int sy = (offs % 32);
        // Because screen is rotate
        int sy = offs % 32;
        int sx = offs / 32;
        if (!galaxianFlipX)
            sx = 31 - sx;
        if (galaxianFlipY)
            sy = 31 - sy;
        int tileIndex = boardMemory[0x5000 + offs];
        int paletteIndex = boardMemory[0x5800 + 2 * (offs % 32) + 1] & 0x07;
        GameDrawElement(screenBitmap, sx * 8, sy * 8, galaxianFlipX, galaxianFlipY, tileIndex, paletteIndex, TRANSPARENCY_NONE, TRANSPARENT_NONE_COLOR);
    }
    // scroll
    for (uint8_t l = 0; l < 32; l++)
    {
        uint8_t scroll = boardMemory[0x5800 + 2 * l] % screenWidth;
        GameScrollLine(l, scroll, 8);
    }
    /* Draw the bullets */
    element = allGfx[2];
    visibleArea = allGames[currentGame].video.visibleArea;
    for (int offs = 0; offs < 0x20; offs += 4)
    {
        int color = 6; // 1; /* white */
        if (offs == 7 * 4)
            color = 7;                                    // 0; /* yellow */
        int y = 255 - boardMemory[0x5860 + offs + 3] - 1; // Machine->drv->gfxdecodeinfo[2].gfxlayout->width;
        int x = boardMemory[0x5860 + offs + 1];
        if (galaxianFlipY)
            y = 255 - y;
        GameDrawElement(screenData, x, y, galaxianFlipX, galaxianFlipY, 0, color, TRANSPARENCY_NONE, TRANSPARENT_NONE_COLOR);
    }
    /* Draw the sprites */
    element = allGfx[1];
    visibleArea = allGames[currentGame].video.visibleArea;
    for (int spriteNumber = 7; spriteNumber >= 0; spriteNumber--)
    {
        const uint8_t *base = &boardMemory[0x5840 + spriteNumber * 4];
        uint8_t sx = base[0];
        uint16_t code = base[1] & 0x3f;
        uint8_t flipx = base[1] & 0x40;
        uint8_t flipy = base[1] & 0x80;
        uint8_t color = base[2] & 7;
        uint8_t sy = base[3];
        GameDrawElement(screenData, sx, sy, flipx, flipy, code, color, TRANSPARENCY_BLACK, TRANSPARENT_NONE_COLOR);
    }
}
